---
layout: single
title: "미니게임 홈페이지"
categories: hani
tag: java
---

## 요구사항과 구현내용
1. 서버와 클라이언트의 분리
    - 백엔드와 프론트엔드를 따로 나누고 포트번호를 다르게 설정
    - 백엔드: Java, JDK17, Spring Boot, JPA, Gradle
    - 프론트엔드: javascript, React, tailwind, yarn, pm2
    - DB: MySQL
2. 각 미니게임별 공지사항, 자유게시판, QnA 페이지 요구
    - 미니게임이 늘어날 경우 해당 미니게임에 대한 공지사항, 자유게시판, QnA 페이지가 생성
    - 공지사항 테이블, 자유게시판 테이블, QnA 테이블을 만들고 게임테이블과 연결해 해당 게임 클릭시 해당 게임에 대한 글만 select되도록 관계 설정
    - 게임테이블의 게임이름을 리스트에 저장해 사용하므로 게임을 새로 추가하면 해당 게임의 탭이 자동적으로 생성
3. 관리자 페이지
    - 일반회원과 관리자의 로그인 페이지 나누기
    - 회원이 타입이 일반회원일 경우 관리자 페이지에서 로그인 불가능
4. 비밀번호 암호화
    - springboot security 사용해 암호화하여 DB에 저장
    - DB에 저장된 암호화된 비밀번호와 화면에서 입력한 텍스트를 암호화해 비교해 일치시 로그인
5. 외부 api를 사용한 회원가입 및 로그인 (카카오, 네이버, 구글)
6. 이메일, 휴대폰 문자인증을 사용한 본인확인 인증
    - 이메일: 구글
    - 휴대폰 문자인증: 알리고
    - @Scheduled를 사용해 1시간 마다 10분 전까지의 DB에 저장된 인증번호 자동삭제
7. pc웹페이지의 화면구성과 모바일 웹페이지의 화면 구성 구현: 반응형 레이아웃
    - tailwind를 사용해 화면의 넓이에 따라 이미지의 크기, 배열 등 변화
8. 메인페이지 이미지 슬라이드
    - React-Slick 라이브러리 커스텀해 사용
9. 포트포워딩으로 외부접속 허용해 관계자 피드백
    - 백엔드: application.properties 파일에서 server.address=0.0.0.0 설정
    - 프론트엔드: vite의 --host 0.0.0.0을 사용
10. 빌드
    - 백엔드: jar파일로 빌드 후 실행
    - 프론트엔드: vite로 React 빌드 후 pm2를 사용해 무중단 배포
11. 구글 원격을 사용해 환경변수 등록 후 백엔드와 프론트엔드 프로젝트 세팅 후 배포

## 개발 후기
1. 리엑트를 처음 사용해 컨포넌트를 사용해 화면을 만드는 방법을 익힐 수 있었다.
2. 서버와 클라이언트의 분리해 CORS오류가 나타났다. 
CORS란 Cross-Origin Resource Sharing의 줄임말이다. 동일한 localhost라도 포트번호만 다르더라도 CORS오류가 난다는 것을 알 수 있었다. 에러 자체는 프론트엔드에서 나타나지만 사실상 실질적인 해결은 백엔드에서 작업을 해야 하기 때문에 문제 원인을 파악하는 것과 문제 해결하는 것이 어렵다. 해당 오류를 해결하기 위해 백엔드의 SecurityConfig파일에서 CORS오류 설정을 해줘야했다.  
WebSecurityConfigurerAdapter를 사용해 설정해주었는데 코드에 중간줄이 떴다. 해당코드는 작동은 되지만 올바르지 않다는 뜻이다. 검색 끝에 2022년인 비교적 최근 Spring Security 5.4버전부터는 <u>WebSecurityConfigurerAdapter대신 SecurityFilterChain을 사용하라는 공식 문서</u>를 찾을 수 있었다. 해당 공식 문서의 링크를 첨부한다.  
[spring cors오류 해결 공식문서](https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter)
3. 본인확인 인증에서 저장된 인증번호는 삭제를 위해 처음으로 @Scheduled 사용해볼 수 있었다.
4. 알리고를 통해 휴대폰 문자인증을 하는 코드를 구현할 때 알리고 공식 홈페이지에서는 JSP의 예제코드만 제공되어 Spring Boot를 사용하는 코드는 없었다. 하지만 필요한 인터페이스를 확인하고 Spring Boot에서 사용하는 import문을 찾아 문자인증 기능을 구현할 수 있었다.